#!/usr/bin/env node
// @ts-check
/**
 * @typedef {import('../src/index').IndexEntry} IndexEntry
 * @typedef {IndexEntry[]} Index
 */
const process = require('process')
const fs = require('fs')
const path = require('path')


/**
 * @param {string} filename
 * @returns {boolean}
 */
const filterFiles = (filename) =>
  !filename.startsWith('index.') &&
  !filename.startsWith('.') &&
  !filename.endsWith('.sha1')

/**
 * @param {string} filename
 * @returns {string}
 */
const readFileSha1 = (filename) =>
  fs.readFileSync(`${filename}.sha1`, 'utf8').split(' ', 1)[0]

/**
 * @param {string} filename
 * @returns {string}
 */
const fileModifiedDate = (filename) =>
  fs.statSync(filename).mtime.toISOString().slice(0, -5) + 'Z'

/**
 * @param {string | undefined} dest
 * @param {string} data
 * @returns {void}
 */
const write = (dest, data) => dest
  ? fs.writeFileSync(dest, data, { encoding: 'utf-8' })
  :â€‰console.log(data)

/**
 * @param {string} filename
 * @returns {Omit<IndexEntry, 'date' | 'size' | 'integrity'>}
 */
const parseBinaryName = (filename) => {
  const [name, version, ...rest] = filename.replace(/\.exe$/, '').split('-')
  const [os, arch, ...variant] = rest.reverse()

  return {
    name,
    version,
    variant: variant.join('-'),
    // @ts-ignore
    arch,
    // @ts-ignore
    os,
    filename,
  }
}

/**
 * @returns {Index}
 */
const generateIndex = () => fs.readdirSync('.')
  .filter(filterFiles)
  .map(filename => ({
    ...parseBinaryName(filename),
    date: fileModifiedDate(filename),
    size: fs.statSync(filename).size,
    integrity: `sha1-${readFileSha1(filename)}`,
  }))

/**
 * Merges `oldIndex` and `newIndex`. If both includes entry with the same
 * filename and integrity, the old one wins.
 *
 * @param {Index} oldIndex
 * @param {Index} newIndex
 * @returns {Index}
 */
const mergeIndexes = (oldIndex, newIndex) => newIndex.reduce((acc, newEntry) => {
  const idx = oldIndex.findIndex(entry => entry.filename === newEntry.filename)
  if (idx < 0) {
    acc.push(newEntry)
  } else if (acc[idx].integrity !== newEntry.integrity) {
    acc[idx] = newEntry
  }
  return acc
}, [...oldIndex])

/**
 * @param {Index} index
 * @returns {Index}
 */
const sortIndex = (index) =>
  index.sort((a, b) => a.filename.localeCompare(b.filename))

/**
 * @param {Record<string, string | number | boolean>[]} array
 * @returns {string}
 */
const stringifyAsCsv = (array) => {
  if (array.length < 1) return ''

  return [
    Object.keys(array[0]).join(','),
    ...array.map(item => Object.values(item).join(','))
  ].join('\n')
}


const argv = process.argv.slice(2)

if (argv[0] === '-h' || argv[0] === '--help') {
  console.log('Usage: generate-index [--json | --csv] [<dir-path> [<out-file>]]')
  process.exit(0)
}
const format = argv[0] && argv[0].startsWith('--') ? argv.shift().slice(2) : 'json'
const outFile = argv[1] && path.resolve(argv[1])
if (argv[0]) {
  process.chdir(argv[0])
}

let index = generateIndex()
if (fs.existsSync('index.json')) {
  const indexFile = fs.readFileSync('index.json', 'utf-8')
  const oldIndex = JSON.parse(indexFile).contents || []

  index = mergeIndexes(oldIndex, index)
}
index = sortIndex(index)

switch (format) {
  case 'json':
    write(outFile, JSON.stringify({ contents: index }, null, 2))
    break
  case 'csv':
    write(outFile, stringifyAsCsv(index))
    break
  default:
    console.error(`Unsupported format: ${format}`)
    process.exit(2)
}
